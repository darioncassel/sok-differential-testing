<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>index</title></head><body><article class="markdown-body"><style TYPE="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
    }
});
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h2 id="sok-ssltls-security-protocol-testing-and-verification"><a name="user-content-sok-ssltls-security-protocol-testing-and-verification" href="#sok-ssltls-security-protocol-testing-and-verification" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>SoK: SSL/TLS Security Protocol Testing and Verification</h2>
<p>Darion Cassel<sup>1</sup>, David Evans<sup>1</sup></p>
<p><sup>1</sup>University of Virginia, Charlottesville, Virginia, USA<br />
<hr></p>
<h4 id="abstract"><a name="user-content-abstract" href="#abstract" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Abstract</h4>
<p>TLS/SSL implementations have been shown to be have a slew of vulnerabilities that can lead to violation of fundamental security properties. We classify current approaches to the testing of TLS implementations through the use of established taxonomies developed in the field of software engineering. Through the lens of this categorization, we assert that security protocol implementation vulnerabilities should be treated differently from traditional software faults because they are a violation of <em>two levels</em> of specification. On one level, they are an exceptional state of some protocol implementation’s state machine. On another level, they are a violation of a protocol model with the consequence of breaking some security property that model intends to guarantee. No current approaches work on both levels but we believe that in order to discover a security fault and understand the implications of that fault without human intervention an approach must be able to combine information from both levels of testing. We present a cohesive workflow that combines two approaches in order to discover faults and classify the semantic threat of those faults concurrently.</p>
<h3 id="i-introduction"><a name="user-content-i-introduction" href="#i-introduction" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>I. Introduction</h3>
<p>TLS/SSL was originated by the company <em>Netscape</em> in 1994 in order to solve the problem of securing HTTP traffic [1]. Netscape never released version 1.0 of its Secure Sockets Layer protocol (SSL) due to the discovery of serious security flaws in the protocol, but went on to release version 2.0 to the public in February of 1995. However, this version too contained many security flaws, leading to a redesign of the protocol and the release of version 3.0 in 1996 [2]. The name Transport Layer Security (TLS) was given to an upgrade of SSL version 3.0 called TLS 1.0 which was defined in January 1999 and was not meant to be inter-operable with SSL 3.0 [3]. </p>
<p>Over the years many vulnerabilities have been found in TLS/SSL leading to the release of new versions of the protocol. TLS 1.1 was defined in April of 2006 in order to add protection against <em>cipher-block chaining</em> (CBC) attacks [4]. TLS 1.2 was defined in August of 2008 and it added <em>authenticated encryption</em>, removing the need for streaming and block ciphers and thus removing vulnerability to CBC attacks [5]. SSL 2.0 was formally deprecated in March of 2011. In June of 2011 the BEAST attack [6] exploiting predictable <em>initialization vectors</em> (IVs) is released. Although the changes of TLS 1.1 and TLS 1.2 protect against BEAST, the adoption was slow of these updates leading to a large swath of vulnerable servers. In September of 2012 Duong and Rizzo release the CRIME attack which exploits TLS compression [7], leading to a rollback of that feature. In February of 2013 the Lucky Thirteen attack is released that executes <em>padding oracle</em> attacks against CBC suites [8]. In October of 2014 the publication of the POODLE attack that also leverages a padding oracle to perform a man-in-the-middle attack leads to SSL version 3.0 being considered insecure [9]. SSL version 3.0 is formally deprecated in June of 2015 [10]. Work on TLS version 1.3 has begun as of July of 2016.</p>
<p>According to a classic definition from the field of software engineering, software testing consists of the dynamic verification that a program provides expected behaviors on a finite set of test cases [11]. However, this definition is too coarse for our purposes as software testing has evolved into a wide and diversified field. The primary difference between various approaches to testing lies in the level of human involvement required to facilitate the testing. On one end of the spectrum lies manual code review, where an individual reads over the source code of a program and attempts to find faults in it [12]. At the other end of the spectrum is fully automated testing requiring no interaction from an individual once testing has commenced [12]. We will focus on the automated testing landscape. Within this sub-field, several theories and methodologies have been extracted and used for the discovery of security vulnerabilities.</p>
<p>The main approaches to testing can be classified at a high level by their level of abstraction. At the lowest level there is dynamic analysis of a running system, followed by static analysis of a code base, and finally at the highest level there is model-checking. Despite there being a wide literature of testing security protocols for vulnerabilities, we find that the there is a clear separation to these approaches leading to inherent limitations for each category in terms the kinds of security vulnerabilities they can discover. Furthermore, there is a lack of a cohesive framework to place each approach into a distinct category such that its merits can be evaluated in terms of its peers.</p>
<p>We are motivated to provide a framework for the classification of security protocol testing and verification approaches in order to address these issues. We find that in the light of a granular framework, clear similarities and differences can be found within approaches. Correspondingly we also seek to provide a framework for the classification of the possible results of an approach. We believe that these combined classifications will explain what features of a particular approach are essential to the kinds of results it discovered, what features are common amongst approaches and may be abstracted into a larger framework, and which approaches can be combined to leverage multiple pieces of information to generate more meaningful results.</p>
<p>Our primary contributions are: (1) Establishing a framework for fine-grained classification of security protocol testing methodologies. (2) Determining a framework for the categorization and evaluation of the results of different testing approaches. (3) Providing a holistic comparison of multiple approaches on the basis of their classification and the classification of their results. (4) Proposing a &lsquo;combined approach&rsquo; that leverages two or more distinct approaches to discover a security vulnerability at the level of an exceptional state of a protocol implementation and to determine the threat or meaning of the vulnerability by concurrently determining the way in which it violates the protocol model&rsquo;s security guarantees. (5) Identification of challenges for future research. </p>
<p>In Section II, we provide background on TLS/SSL at the protocol level and define terminology for software testing and protocol verification. Then, in Section III, we give a framework for the classification of methodologies and their results. In Section IV we proceed to use this framework to classify a series of &lsquo;representative approaches&rsquo;. We provide a comparison of methodologies and results in Section V, and present a combined approach and its results in Section VI-VII. Finally we discuss related works in Section VIII and conclude with a discussion of possible future research in Section IX.</p>
<h3 id="ii-background-and-definitions"><a name="user-content-ii-background-and-definitions" href="#ii-background-and-definitions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>II. Background and Definitions</h3>
<h4 id="background-on-ssltls"><a name="user-content-background-on-ssltls" href="#background-on-ssltls" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Background on SSL/TLS</h4>
<p>The TLS protocol is designed to provide encryption, authentication, and data integrity to the parties using the protocol. In order for this to occur, the two parties first participate in the TLS <em>handshake protocol</em> which includes a component of <em>certificate validation</em>. Once that is complete data is exchanged though the use of the <em>record layer protocol</em>. Most efforts to test and verify TLS have found vulnerabilities in the handshake protocol and the certificate validation phase. As such we will focus on describing them in detail here.</p>
<p><em>A. The TLS Handshake</em></p>
<p>Let us consider two parties, Alice and Bob. The primary goal of the handshake is to provide privacy and reliability for Alice and Bob&rsquo;s communications through the establishment of secret keys. </p>
<p><center><img src="https://hpbn.co/assets/diagrams/b83b75dbbf5b7e4be31c8000f91fc1a8.svg" alt="TLS Handshake" style="width:800px;"/><br><br />
<sup>Fig. 1: TLS Handshake [13] </sup></center></p>
<p>At a fundamental level, the handshake consists of three messages. The first is the <em>ClientHello</em> message with which Alice initiates the protocol, transmits her SSL/TLS version number and sends a set of cryptographic algorithms she supports called the <em>ciphersuite</em>.</p>
<p>Bob will then reply with the <em>ServerHello</em> message that has his choice of TLS protocol version, a choice of ciphersuite, and his certificate. When Alice receives this messages she must perform certificate validation on the Bob&rsquo;s certificate, and must agree to the choices of protocol version and ciphersuite. </p>
<p>If Alice accepts Bob&rsquo;s certificate and accepts the shared SSL/TLS version and cipher, then the client initiates a <em>key exchange protocol</em>, namely RSA or Diffie-Hellman, which allows for the establishment of a symmetric key to be used for the rest of the connection.</p>
<p>It should be noted that SSL 3.0 onwards supports <em>session resumption</em> [33]. During the first run of the TLS protocol between Alice and Bob, they go through the full handshake protocol as detailed above. However, on future connections, session resumption allows for re-connection without use of the an abbreviated handshake. Specifically, if Alice sends a ClientHello message that includes a <em>session identifier</em> of a session that Bob has recorded as active, then Bob will assume that Alice wants to resume that previous session. A new secret is not exchanged, instead the previous keys are recomputed with new nonces and used. </p>
<p><em>B. Certificate Validation</em></p>
<p>X.509 certificate validation is perhaps the most complex piece of the TLS handshake protocol. It involves the use of a transitive process called <em>chain of trust verification</em>. Each SSL/TLS client trusts a certain number of certificate authorities (CAs) whose X.509 certificates are usually included with the client&rsquo;s Operating System or browser [32]. This is considered to be the client&rsquo;s <em>root of trust</em>.</p>
<p><center><img src="https://hpbn.co/assets/diagrams/bb75b8bd469ce5b703b76abb7042e978.svg" alt="Chain of Trust" style="width:800px;"/><br><br />
<sup>Certificate Chain of Trust</sup></center></p>
<p>Each X.509 certificate that the client receives from a server it is attempting to connect with has an <em>issuer</em> field that contains the name of the certificate authority (CA) that issued the certificate. This server certificate is required to be accompanied by the certificate of the issuing CA, and if that issuer is not a <em>root CA</em>, then all of the certificates up to the root CA need to be included. It is this chain of certificates going from a server certificate to a root CA, the chain of trust, that needs to be validated by the client. Due to the complexity of the X.509 certificates themselves, this is not a simple task. Some of the checks involved in validating the chain are [14]:</p>
<ul>
<li>Checking that each certificates in the chain is signed by a CA immediately above it and the root of the chain is a client&rsquo;s trusted root CA.</li>
<li>If the certificate is a version 1 or version 2 certificate then the client must either reject it or verify it by out-of-band means</li>
<li>Certificates can have extensions. Each of these is either designated as <em>critical</em> or <em>non-critical</em>. A certificate with an unrecognized (by the client) critical extension must be rejected.</li>
<li>If a certificate contains a <em>name constraints</em> extension, then the subject name in the next certificate in the chain must satisfy those name constraints. This is considered a critical extension.</li>
</ul>
<p>It is due to this complexity that the certificate validation phase of the TLS protocol is a hotbed of security vulnerabilities.</p>
<p><em>C. The Record Protocol</em></p>
<p>Similarly to TCP or IP, data that is exchanged within a TLS session is framed using a protocol. The record protocol allows for the identification of different types of messages, either handshake, alert, or data, via the <em>Content Type</em> field, and includes authentication of the encrypted data via a <em>message authentication code</em> (MAC).</p>
<p><center><img src="https://hpbn.co/assets/diagrams/4603275cd98c93aeb8c46b1b1afa0ba6.svg" alt="TLS Record Structure" style="width:800px;"/><br><br />
<sup>Fig. 2: TLS Record Structure [13]</sup></center></p>
<p>The process for delivering application data using the record protocol is that the data is divided into blocks of a maximum size of 16 KB. A MAC or HMAC is then added to each block and the data is encrypted using the ciphersuite that was negotiated during the handshake. Depending on the ciphersuite being used, padding might be added to the data. The reverse of this process is used by the client when it receives a frame of data.</p>
<h4 id="software-security-testing-background-and-definitions"><a name="user-content-software-security-testing-background-and-definitions" href="#software-security-testing-background-and-definitions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Software Security Testing Background and Definitions</h4>
<p>In a classical sense, <em>software testing</em> consists of the dynamic verification that a program provides expected behaviors on a finite set of <em>test cases</em> called a <em>test suite</em> [11]. Closely related is the notion of <em>dynamic testing</em> that evaluates software by observing its execution [15]. On the other hand, <em>Static testing</em> checks <em>software development artifacts</em> (i.e requirements, design, or code) without the execution of these artifacts. Static testing is usually performed either through <em>manual reviews</em> or <em>automated analysis</em>.</p>
<p>After a particular test case is executed, the observed and intended behaviors of the <em>software under test</em> (SUT) are compared, resulting in a <em>verdict</em> that is either [16]:<br />
- <em>Pass</em>: the behaviors conform<br />
- <em>Fail</em>: the behaviors do not conform<br />
- <em>Inconclusive</em>: it cannot be determined whether the behaviors conform.</p>
<p>The mechanism that is used for determine the verdict is called the <em>test oracle</em>. If the SUT is being checked for compliance with user or customer needs this is called <em>validation</em>. If the SUT is being tested against a specification this is called <em>verification</em>.</p>
<p>In the event of a <em>failure</em>, which is an undesired behavior that either fails validation or verification, a cause of failure called a <em>fault</em> may be assigned to it.</p>
<p>A fault can be either [17]:<br />
- A <em>static defect</em> in the software caused by human error in the specification, design or coding process.<br />
- A <em>behavioral description</em> of how the software deviates from the intended behavior.<br />
- A <em>vulnerability</em>, which is fault that is a <em>security flaw</em> and results in a violation of a security property.</p>
<p>The meaning of vulnerability is one of two things, either the security mechanism necessary for protecting against that vulnerability is missing, or the security mechanism has been implemented in a faulty way.</p>
<p>The <em>exceptional element</em> is an the input that provokes an undesirable behavior in the SUT. The exceptional element can violate a protocol specification or it can sometimes be a legal input that exploits an ambiguity in the specification [18].</p>
<p>The <em>instrumentation</em> used to monitor the SUT can be divided into two categories, <em>out-of-band instrumentation</em>, such as debuggers, and <em>in-band instrumentation</em>, which is added to the program via the test <em>injection vector</em>, the same interface used to give the test case to the SUT [18].</p>
<p><em>Security testing</em> verifies and validates software system requirements related to security properties. Typical security properties under test are [19]:<br />
- <em>Confidentiality</em>, which is the assurance that information is not disclosed to unauthorized individuals, processes, or devices<br />
- <em>Integrity</em>, which is provided when data is unchanged from its source and has not been accidentally or maliciously modified, altered, or destroyed. <br />
- <em>Availability</em>, which guarantees timely, reliable access to data and information services for authorized users.<br />
- <em>Authentication</em>, which is a security measure designed to establish the validity of a transmission, message, or originator, or a means of verifying an individual’s authorization to receive specific categories of information. <br />
- <em>Authorization</em>, which provides access privileges granted to a user, program, or process.<br />
- <em>Non-repudiation</em>, which is the assurance that none of the partners taking part in a transaction can later deny of having participated.</p>
<p>There are several paradigms for performing security testing depending on what stage during the application&rsquo;s development the testing occurs. However, it should be noted that testing methods from earlier stages can be used for later stages but methods from later stages cannot be used during earlier stages of the application development lifecycle [17].<br />
- <em>Model-based</em> security testing is grounded on requirements and design models created during the analysis and design phase. <em>Model-based testing</em> (MBT), manually selected algorithms automatically and systematically generate test cases from a set of models of the system under test or its environment<br />
- <em>Code-based</em> testing and static analysis on source and bytecode created during development<br />
- <em>Penetration testing and dynamic analysis</em> on running systems, either in a test or production environment<br />
- <em>Security regression testing</em> performed during maintenance.</p>
<p>The <em>test scope</em> describes the granularity with which the SUT is being evaluated. Usually, this can be divided into <em>component</em>, <em>integration</em>, <em>system</em>, or <em>regression</em> testing:<br />
- Component testing, also referred to as <em>unit testing</em>, checks the smallest testable software component in isolation.<br />
- Integration testing tests a set of combined components.<br />
- System testing tests the system as a whole, including and subsets of components.<br />
- Regression testing is a form of selective testing that checks that certain software modifications have not resulted in faults.</p>
<p>A <em>test plan</em> is a set of <em>test objectives</em>, <em>test scope</em>, and <em>test methods</em> that identifies features to be tested and <em>exit criteria</em> that define conditions when testing will end [20]. A typical form of exit criteria is <em>coverage</em>, which measures how much of a particular program is reached during testing.</p>
<p>The <em>accessibility</em> of software development artifacts under test is a measure of how much information is available <em>a prior</em> about the SUT [11].<br />
- <em>White-box testing</em> uses test cases that are derived based on information about how the software has been designed or coded.<br />
- <em>Black-box testing</em> uses test cases that rely only on the input/output behavior of the software is available. It is frequently used in security testing where testing is often done to mimic external attacks from an adversary.</p>
<p>As noted, black-box testing does not require access to source code or other development artifacts of the SUT. Testing is typically performed via interaction with the SUT using:<br />
- <em>Penetration testing</em>, in which the SUT is tested from &ldquo;outside&rdquo; in a setup that is comparable to an actual attack from a third party [113]<br />
- <em>Fuzzing</em>, which feeds random data to a program &ldquo;until it crashes&rdquo; [17].<br />
- <em>Mutation-based fuzzing</em>, where the fuzzer has knowledge about the input format of the program under test, such as existing data samples [22].<br />
- <em>Generation-based fuzzing</em>, which uses a model of the input data for generating test data [23].<br />
- <em>Concolic testing</em>, which combines symbolic execution that is a static source code analysis technique with dynamic testing [24].</p>
<h4 id="protocol-verification-background-and-definitions"><a name="user-content-protocol-verification-background-and-definitions" href="#protocol-verification-background-and-definitions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Protocol Verification Background and Definitions</h4>
<p><em>Abstract static analysis</em> is the automatic computation of information about the behavior of a program without executing. This kind of analysis is usually used to compute <em>approximate</em> but <em>sound</em> conjectures about the behavior of a program. We say that are sound because they are guaranteed to not be misleading [25].</p>
<p>The analysis process is vulnerable to two kinds of errors:<br />
- <em>A spurious warning</em>, which is an error message about a fault that does not exist in the program.<br />
- <em>A missed bug</em>, which means that the analysis procedure did not report a fault that actually exists in the program. </p>
<p>We say that a program analysis method is <em>flow sensitive</em> if the order of execution of statements in the program is considered, <em>path sensitive</em> if the analysis distinguishes between paths through a program and attempts to only consider feasible ones, <em>context sensitive</em> if method calls are analyzed differently based on the call site, and <em>inter-procedural</em> if the bodies of method calls are also analyzed [25].</p>
<p>Protocol verification usually makes use of the <em>software model checking</em> methodology [26]. This consists of a <em>model</em> of the program, which is a set of <em>states</em>, such as the evaluation of the program counter, the values of program variables, and the configuration fo the stack and heap, and a set of <em>transitions</em> that describe how the programs moves from one state to another.</p>
<p>In the context of model-checking, a <em>specification</em>, or <em>correctness property</em> is a literal logical formula of states and transitions. If a state violating a specification is found, a <em>counterexample</em>, which is an execution trace demonstrating the error, is produced.</p>
<p>Thus, we say that a model checker can return one of three results:<br />
- <em>Pass</em>, indicating that the property is satisfied<br />
- <em>Fail</em>, indicating that the property is not satisfied and that a counterexample exists<br />
- <em>Inconclusive</em>, the model checker cannot compute verification in a &ldquo;reasonable&rdquo; amount of time</p>
<p>Model checking tools verify <em>partial specifications</em> that are classified as <em>safety</em>, which expresses the unreachability of bad states, and <em>liveness</em>, which specifies that a &ldquo;good&rdquo; state is eventually reached, such as a request to a webserver being served eventually.</p>
<p>The principle problem with vanilla model checking is <em>state-space explosion</em>, which means that the state-space of a software program is exponential in terms of its various parameters such as the number of variables and the width of the datatypes [27].</p>
<p>The state-space explosion is particularly a problem with <em>explicit-state model checking algorithms</em> that directly index states and use graph algorithms to explore the state space. Some efficiency may be gained by checking for property violation <em>on-the-fly</em> with new states, such that the entire graph does not have to be built to perform the analysis. Other improvements include the compression of explored states that are then stored in a hashtable to ensure that their successors are not recomputed. Finally, <em>partial order reduction</em> is used to prune the state space exploration of concurrent programs.</p>
<p>An alternative to explicit-state model checking algorithms is <em>symbolic model checking algorithms</em> that use implicit representations of sets of states. Common symbolic representations are <br />
- <em>BDDs</em>, which are obtained from a <em>boolean decision tree</em> and permit boolean functional equivalence for efficient checking [28]<br />
- <em>Propositional logic for finite sets</em>, which are more memory efficient at the cost of computation time [29]<br />
- <em>Finite automata for infinite sets</em> [30]</p>
<p>Another alternative is <em>bounded model checking</em> (BMC). This technique involves &ldquo;unwinding&rdquo; the model under verification <em>k</em> times together with a property to form a propositional formula that is then passed to a SAT solver [25]. The result of the test is viewed as a <em>pass</em> if and only if there is a trace of length <em>k</em> that refutes the property. The result is viewed as <em>inconclusive</em> if the formula is unsatisfiable.</p>
<p>There is a level of care to be given to the models themselves. We say that a model of a protocol is a <em>symbolic model</em>, often called the Dolev-Yao Model [31], is the cryptographic primitives are represented by function symbols considered as black-boxes, messages are terms on these primitives, the adversary is restricted to using these primitives, and the model assumes perfect cryptography. On the other hand, in the <em>computational model</em> messages are bitstrings, the cryptographic primitives are functions from bitstrings to bitstrings, the adversary is a probabilistic Turing machine, and a security property is considered to hold when the probability that it does not hold is negligible in the security parameter [31].</p>
<p>Finally, we say that <em>trace properties</em> are properties that can be defined on each execution trace of the protocol, and <em>equivalence properties</em> mean that an adversary cannot distinguish two processes [31].</p>
<h3 id="iii-framework-for-methodology-and-result-classification"><a name="user-content-iii-framework-for-methodology-and-result-classification" href="#iii-framework-for-methodology-and-result-classification" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>III. Framework for Methodology and Result Classification</h3>
<p>In order to classify methodologies, we shall be using the following approach, first we will determine the <em>type</em> of testing, which will be one of:<br />
- <em>Dynamic Testing</em><br />
- <em>Static Testing</em></p>
<p>If an approach uses dynamic testing, it can be further classified into:<br />
- <em>Penetration testing</em><br />
- <em>Fuzzing</em></p>
<p>If fuzzing is being used, it can be specified either as:<br />
- <em>Random fuzzing</em><br />
- <em>Mutation-based fuzzing</em><br />
- <em>Generation-based fuzzing</em><br />
- <em>Concolic testing</em></p>
<p>If the approach uses static testing, it can be classified into:<br />
- <em>Model-checking</em><br />
- <em>Code-based analysis</em></p>
<p>If model-checking is being used, it can be specified as:<br />
- <em>Explicit-state model-checking</em><br />
- <em>Symbolic model-checking</em><br />
- <em>Bounded model-checking</em></p>
<p>The model used in model-checking is either:<br />
- <em>Manually specified</em><br />
- <em>Automatically generated</em></p>
<p>Next, the <em>exceptional element</em> and the <em>test oracle</em> shall be categorized. The exceptional element can be portrayed either as:<br />
- An <em>execution trace</em><br />
- An <em>exceptional input</em></p>
<p>The <em>test oracle</em> can be:<br />
- A <em>reference implementation</em><br />
- A <em>specification</em><br />
- <em>Manual inspection</em></p>
<p>The <em>reference implementation</em> and the <em>specification</em> are either:<br />
- <em>Manually determined</em><br />
- <em>Automatically generated</em></p>
<p>Also in consideration are the <em>test scope</em> and the <em>exit criteria</em>. The test scope can be either<br />
- <em>Component testing</em><br />
- <em>Integration testing</em><br />
- <em>System testing</em><br />
- <em>Regression testing</em></p>
<p>The <em>exit criteria</em> can be:<br />
- <em>Manual</em><br />
- <em>Exhaustion</em><br />
- <em>Coverage</em></p>
<p>For dynamic testing methods, the <em>injection vector</em> and <em>instrumentation</em> are considered. The injection vector and can be one of:<br />
- <em>Server interaction</em><br />
- <em>Simulated interaction</em></p>
<p>The <em>instrumentation</em> can be<br />
- <em>Out-of-band</em><br />
- <em>In-band</em></p>
<p>Additionally, we consider the <em>accessibility</em> of test artifacts (relating to the SUT) as either:<br />
- <em>White-box</em><br />
- <em>Black-box</em></p>
<p>We classify whether the methodology is vulnerable to <em>spurious warnings</em> or <em>missed bugs</em> and consider the form of vulnerabilities received:<br />
- <em>Exceptional traces</em><br />
- <em>Manually-inspected behavior</em><br />
- <em>Source code correspondences</em><br />
- <em>Counterexamples</em> (for model checking)</p>
<p>Finally, we consider how the discovered vulnerabilities are corresponded to violations of security properties:<br />
- <em>Manually</em><br />
- <em>Automatically</em></p>
<p>To summarize, each methodology shall be classified using these metrics:</p>
<p>(6) Core Properties<br />
1. Type<br />
2. Test Scope<br />
3. Exceptional Element<br />
4. Test Oracle<br />
5. Oracle Specification<br />
6. Exit Criteria</p>
<p>(4) Dynamic Testing Properties<br />
1. Type<br />
2. In-test Accessibility<br />
3. Injection Vector<br />
4. Instrumentation</p>
<p>(2) Static Testing Properties<br />
1. Type<br />
2. Model Generation</p>
<p>(4) Result Properties<br />
1. Spurious Warnings?<br />
2. Missed Bugs?<br />
2. Form of Vulnerabilities<br />
3. Threat Assessment</p>
<h3 id="iv-classifications-of-methodologies-and-results"><a name="user-content-iv-classifications-of-methodologies-and-results" href="#iv-classifications-of-methodologies-and-results" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>IV. Classifications of Methodologies and Results</h3>
<p>We shall be looking at the following &lsquo;representative approaches&rsquo; that were chosen because they present an archetype of a particular approach. We tried to ensure that we don&rsquo;t duplicate coverage of similar approaches:</p>
<ul>
<li>&ldquo;Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations&rdquo;   (<em>Frankencerts</em>) [32]</li>
<li>&ldquo;Finite-State Analysis of SSL 3.0&rdquo;   (<em>Finite-State Analysis of SSL 3.0</em>) [33]</li>
<li>&ldquo;Not-quite-so broken TLS: lessons in re-engineering a security protocol specification and implementation&rdquo;   (<em>Not-quite-so-broken TLS</em>) [34]</li>
<li>&ldquo;A Messy State of the Union: Taming the Composite State Machines of TLS&rdquo;  (<em>A Messy State of the Union</em>) [35]</li>
<li>&ldquo;Systematic Fuzzing and Testing of TLS Libraries&rdquo;  (<em>Systematic Fuzzing and Testing of TLS Libraries</em>) [36]</li>
<li>&ldquo;Protocol state fuzzing of TLS implementations&rdquo;   (<em>Protocol state fuzzing of TLS implementations</em>) [37]</li>
<li>&ldquo;Testing Embedded TLS Implementations Using Fuzzing Techniques and Differential Testing&rdquo;  (<em>Testing Embedded TLS Implementations</em>) [38]</li>
</ul>
<p><em>A. Frankencerts</em></p>
<p>The Frankencerts paper implemented a methodology for large-scale testing of certificate validation logic in SSL/TLS implementations through the use of randomly generated synthetic certificates built from parts of real certificates. The authors then applied differential testing to uncover discrepancies between several SSL/TLS implementations such as OpenSSL, NSS, CyaSSL, GnuTLS, PolarSSL, and MatrixSSL. 208 discrepancies were identified, which could be attributed to 15 distinct root causes.</p>
<p><em>Core Properties</em> </p>
<h5 id="1-type"><a name="user-content-1-type" href="#1-type" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The Frankencerts paper uses a <em>dynamic testing</em> approach.</p>
<h5 id="2-test-scope"><a name="user-content-2-test-scope" href="#2-test-scope" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The scope is <em>system testing</em>. Although the authors were attempting to test just certificate validation, they had to run the full implementations as the SUT and thus could theoretically receive faults from other parts of the system than the certificate validation subsystem.</p>
<h5 id="3-exceptional-element"><a name="user-content-3-exceptional-element" href="#3-exceptional-element" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p>The exceptional element is presented as an <em>exceptional input</em>, in this case a &ldquo;frankencert,&rdquo; which is a X.509 certificate automatically generated from a set of sample input data (other certificates).</p>
<h5 id="4-test-oracle"><a name="user-content-4-test-oracle" href="#4-test-oracle" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>The test oracle is a <em>reference implementation</em>, but is a bit more nuanced than that; in the case of this approach the test oracle is discrepancies between the behavior of the implementations, given that each implementation is presented with the same frankencert.</p>
<h5 id="5-oracle-specification"><a name="user-content-5-oracle-specification" href="#5-oracle-specification" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Oracle Specification</h5>
<p>Since there is no single reference implementation, the SUT is a collection of implementations, it is not possible to classify the oracle specification is either manually-determined or automatically-generated. Thus, the oracle specification will be listed as N/A.</p>
<h5 id="6-exit-criteria"><a name="user-content-6-exit-criteria" href="#6-exit-criteria" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Exit Criteria</h5>
<p>The exit criteria is <em>exhaustion</em>. Once all of the generated test case data was exhausted, the testing ended. It should be noted that there is a high theoretical ceiling for how much test data could be generated so it is technically possible for this method to reach coverage, at least of the certificate validation sub-system, however the issue is that the coverage is in no way measured and thus it is not possible to assess when it has been reached.</p>
<p><em>Dynamic Testing Properties</em></p>
<h5 id="1-type_1"><a name="user-content-1-type_1" href="#1-type_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>This methodology uses <em>mutation-based fuzzing</em> wherein a sample of input data is permuted to form new test cases. Specifically, the authors use a set of valid X.509 certificates and then permute them separating them into pieces and randomly combining those pieces.</p>
<h5 id="2-in-test-accessibility"><a name="user-content-2-in-test-accessibility" href="#2-in-test-accessibility" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. In-test Accessibility</h5>
<p>This methodology uses <em>black-box</em> testing; the tests have no knowledge of the source code; the SUT is viewed purely as an input/output machine.</p>
<h5 id="3-injection-vector"><a name="user-content-3-injection-vector" href="#3-injection-vector" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Injection Vector</h5>
<p>The injection vector is <em>server-interaction</em>. The authors set up a server that would present connecting clients (running one of the SSL/TLS libraries) with a frankencert.</p>
<h5 id="4-instrumentation"><a name="user-content-4-instrumentation" href="#4-instrumentation" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Instrumentation</h5>
<p>The instrumentation is <em>in-band</em>. The clients set up by the authors record the answers, including error codes, given by the SSL/TLS implementations when presented with the frankencert.</p>
<p><em>Result Properties</em></p>
<h5 id="1-spurious-warnings"><a name="user-content-1-spurious-warnings" href="#1-spurious-warnings" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings?</h5>
<p>This method is <em>not vulnerable</em> to spurious warnings. Since differential testing is being employed, any discrepancy must be an actual fault in one of the implementations since they all purport to implement the same specification.</p>
<h5 id="2-missed-bugs"><a name="user-content-2-missed-bugs" href="#2-missed-bugs" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs?</h5>
<p>This methodology is by no means exhaustive in testing certificate validation and is thus <em>vulnerable</em> to missed bugs.</p>
<h5 id="3-form-of-vulnerabilities"><a name="user-content-3-form-of-vulnerabilities" href="#3-form-of-vulnerabilities" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>The form of vulnerabilities is <em>exceptional traces</em>, as mentioned, answers and error codes from the implementations are recorded.</p>
<h5 id="4-threat-assessment"><a name="user-content-4-threat-assessment" href="#4-threat-assessment" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>The threat assessment of vulnerabilities had to be done <em>manually</em>. If a given implementation had a discrepancy, it had to be carefully tested (manually) to determine what caused that discrepancy.</p>
<p><em>B. Not-quite-so broken TLS - Fuzzing</em></p>
<p>With the Not-quite-so-broken TLS, the authors of the paper sought to build a reference TLS implementation (nqsb-TLS) built through a re-engineered approach to security protocol specification and implementation. Although the aim of the paper was not the explicit testing of a TLS implementation, the authors&rsquo; reference implementation can be used as a test oracle and was used for testing in two forms. This section will cover the first form which was applying the Frankencert method to test OpenSSL, using nqsb-TLS as the test oracle.</p>
<p><em>Core Properties</em></p>
<h5 id="1-type_2"><a name="user-content-1-type_2" href="#1-type_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The type of testing was <em>dynamic testing</em>. </p>
<h5 id="2-test-scope_1"><a name="user-content-2-test-scope_1" href="#2-test-scope_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The test scope was <em>system testing</em>, in this case, the entirety of OpenSSL.</p>
<h5 id="3-exceptional-element_1"><a name="user-content-3-exceptional-element_1" href="#3-exceptional-element_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p>This testing used <em>exceptional inputs</em>. The mutation-based fuzzing fed mutated certificates inspired by the mechanism of <em>Frankencerts</em>.</p>
<h5 id="4-test-oracle_1"><a name="user-content-4-test-oracle_1" href="#4-test-oracle_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>The test oracle in the case of the mutation-based fuzzing testing was a <em>reference implementation</em>, in this case, nqsb-TLS.</p>
<h5 id="5-oracle-specification_1"><a name="user-content-5-oracle-specification_1" href="#5-oracle-specification_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Oracle Specification</h5>
<p>The specification was <em>manually-determined</em> based on knowledge of what is or is not supposed to be done as part of the TLS protocol. The main thrust of the paper was to reverse engineer a specification of TLS and then encode this discovered specification into a new implementation of TLS; nqsb-TLS.</p>
<h5 id="6-exit-criteria_1"><a name="user-content-6-exit-criteria_1" href="#6-exit-criteria_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Exit Criteria</h5>
<p>The exit criteria for the mutation-based fuzzing was <em>exhaustion</em> of the test set. Similarly to <em>Frankencerts</em>, once the generated test case data was exhausted, the testing ended.</p>
<p><em>Dynamic Testing Properties</em></p>
<h5 id="1-type_3"><a name="user-content-1-type_3" href="#1-type_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The type is specifically <em>mutation-based fuzzing</em> The Frankencert method was used to generate 10,000 X.509 certificate chains and these were given to nqsb-TLS.</p>
<h5 id="2-in-test-accessibility_1"><a name="user-content-2-in-test-accessibility_1" href="#2-in-test-accessibility_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. In-test Accessibility</h5>
<p>During the application of the Frankencert method, the testing was done in a <em>black-box</em> way; the tests were executed at the level of viewing the SUT as an input/output machine; the tests had no access to the source code of the implementations.</p>
<h5 id="3-injection-vector_1"><a name="user-content-3-injection-vector_1" href="#3-injection-vector_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Injection Vector</h5>
<p>The injection vector in was through <em>server-interaction</em>. A server presented the clients running nqsb-TLS and OpenSSL with the frankencerts.</p>
<h5 id="4-instrumentation_1"><a name="user-content-4-instrumentation_1" href="#4-instrumentation_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Instrumentation</h5>
<p>The instrumentation was an <em>in-band</em>, the authors could monitor whether either implementation accepted the frankencerts through the recorded output of the implementation.</p>
<p><em>Result Properties</em></p>
<h5 id="1-spurious-warnings_1"><a name="user-content-1-spurious-warnings_1" href="#1-spurious-warnings_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings?</h5>
<p>Since the frankencerts method was used this methodology was <em>not vulnerable</em> to false positives.</p>
<h5 id="2-missed-bugs_1"><a name="user-content-2-missed-bugs_1" href="#2-missed-bugs_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs?</h5>
<p>The testing was by no means exhaustive so this methodology is <em>vulnerable</em> to missed bugs.</p>
<h5 id="3-form-of-vulnerabilities_1"><a name="user-content-3-form-of-vulnerabilities_1" href="#3-form-of-vulnerabilities_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>The faults discovered in OpenSSL were of the form of <em>counterexamples</em>; they were comparisons to what nqsb-TLS did given a particular input. The comparisons could be used to (manually) pinpoint the root causes of vulnerabilities within OpenSSL.</p>
<h5 id="4-threat-assessment_1"><a name="user-content-4-threat-assessment_1" href="#4-threat-assessment_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>The threat assessment was performed <em>manually</em> for each recorded fault; the authors had to look though the source code of OpenSSL to find the root causes of vulnerabilities.</p>
<p><em>B. Not-quite-so broken TLS - Penetration Testing</em></p>
<p>This section will cover the second form of testing performed in the Not-quite-so broken TLS paper.</p>
<p><em>Core Properties</em></p>
<h5 id="1-type_4"><a name="user-content-1-type_4" href="#1-type_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The type of testing was <em>dynamic testing</em>.</p>
<h5 id="2-test-scope_2"><a name="user-content-2-test-scope_2" href="#2-test-scope_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The test scope was <em>system testing</em>, in this case, the entirety of nqsb-TLS was the SUT. Technically, the nqsb-TLS was presented as part of a web-server ot potential attackers, so other pieces of the architecture were under test as well, but their faults were not considered as part of the authors&rsquo; analysis.</p>
<h5 id="3-exceptional-element_2"><a name="user-content-3-exceptional-element_2" href="#3-exceptional-element_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p><em>Exceptional inputs</em>; third-party attackers attempted to use whatever methods available to them to overcome the security of OpenSSL. Their point of access was input to the server.</p>
<h5 id="4-test-oracle_2"><a name="user-content-4-test-oracle_2" href="#4-test-oracle_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>For the penetration testing, the oracle was a form of <em>manual inspection</em>; since the server was set up as a Bitcoin pinata, a successful attack on the server would amount to an oracle purporting a <em>failure</em>. Similarly, the lack of a successful attack could be viewed as a kind of <em>validation</em> of the SUT.</p>
<h5 id="5-oracle-specification_2"><a name="user-content-5-oracle-specification_2" href="#5-oracle-specification_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Oracle Specification</h5>
<p>Since the oracle was manual inspection of the server for successful attacks, there was no specification.</p>
<h5 id="6-exit-criteria_2"><a name="user-content-6-exit-criteria_2" href="#6-exit-criteria_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Exit Criteria</h5>
<p>The exit criteria for the penetration testing was <em>manual</em>, after a period of time the testing ended.</p>
<p><em>Dynamic Testing Properties</em></p>
<h5 id="1-type_5"><a name="user-content-1-type_5" href="#1-type_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>As remarked, this form of testing was <em>penetration-testing</em> where the implementation was given to attempted attacks from malicious third party sources.</p>
<h5 id="2-in-test-accessibility_2"><a name="user-content-2-in-test-accessibility_2" href="#2-in-test-accessibility_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. In-test Accessibility</h5>
<p>A public server was set up and left exposed to attackers. This is a <em>black-box</em> method since the attackers had no access to the source code for nqsb-TLS.</p>
<h5 id="3-injection-vector_2"><a name="user-content-3-injection-vector_2" href="#3-injection-vector_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Injection Vector</h5>
<p>The injection vector was through <em>server-interaction</em>; the attackers could try to attack by communicating with the server and the nqsb-TLS implementation.</p>
<h5 id="4-instrumentation_2"><a name="user-content-4-instrumentation_2" href="#4-instrumentation_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Instrumentation</h5>
<p>The instrumentation was an <em>out-of-band</em>, the authors could could track traces of attacks on the server.</p>
<p><em>Result Properties</em></p>
<h5 id="1-spurious-warnings_2"><a name="user-content-1-spurious-warnings_2" href="#1-spurious-warnings_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings?</h5>
<p>This form of testing is <em>not vulnerable</em> to spurious warnings; any successful form of attack (given that the attack exploited a property of nqsb-TLS) should be viewed as the existence of some vulnerability in nqsb-TLS.</p>
<h5 id="2-missed-bugs_2"><a name="user-content-2-missed-bugs_2" href="#2-missed-bugs_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs?</h5>
<p>This form of testing is <em>vulnerable</em> to missed bugs as it is clearly not exhaustive; the public server was available only for a finite period of time and no measure of coverage was taken.</p>
<h5 id="3-form-of-vulnerabilities_2"><a name="user-content-3-form-of-vulnerabilities_2" href="#3-form-of-vulnerabilities_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>No vulnerabilities were discovered with nqsb-TLS as there were no successful attacks on the server. Thus, this must be marked as N/A.</p>
<h5 id="4-threat-assessment_2"><a name="user-content-4-threat-assessment_2" href="#4-threat-assessment_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>Likewise, since no vulnerabilities were uncovered, there was no opportunity for threat assessment; this is also N/A.</p>
<p><em>C. Finite-State Analysis of SSL 3.0</em></p>
<p>The authors of this paper attempted to analyze the SSL protocol using a finite-state enumeration tool called Mur$\phi$. They completed the analysis by using a sequence of incremental approximations to the SSL 3.0 handshake that is then model-checked using Mur$\phi$. Though this methodology they discovered some anomalies in the session resumption protocol.</p>
<p><em>Core Properties</em></p>
<h5 id="1-type_6"><a name="user-content-1-type_6" href="#1-type_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>This paper uses a finite-state analysis tool and thus is a form of <em>static testing</em>.</p>
<h5 id="2-test-scope_3"><a name="user-content-2-test-scope_3" href="#2-test-scope_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The test scope was <em>component testing</em>; only the SSL 3.0 handshake was under consideration. </p>
<h5 id="3-exceptional-element_3"><a name="user-content-3-exceptional-element_3" href="#3-exceptional-element_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p>The finite state analysis tool Mur$\phi$ presents an <em>execution trace</em>, which in ths case is a sequence of states from the start state to a state exhibiting the problem; a counterexample to a guarantee that some invariant is held by the program.</p>
<h5 id="4-test-oracle_3"><a name="user-content-4-test-oracle_3" href="#4-test-oracle_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>The test oracle in this case is a <em>specification</em> of invariants.</p>
<h5 id="5-oracle-specification_3"><a name="user-content-5-oracle-specification_3" href="#5-oracle-specification_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Oracle Specification</h5>
<p>The form of the specification is a set of Boolean conditions that have to be true in every reachable state; essentially they bound what a &ldquo;safe&rdquo; state is. This had to be <em>manually determined</em> from the authors&rsquo; knowledge of the SSL protocol; the authors had access to the protocol code and were specifically developing a &ldquo;rational reconstruction&rdquo; of the protocol.</p>
<h5 id="6-exit-criteria_3"><a name="user-content-6-exit-criteria_3" href="#6-exit-criteria_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Exit Criteria</h5>
<p>The exit criteria was <em>coverage</em>, the Mur$\phi$ tool exhaustively tests all possible interleavings of protocol and intruder actions to ensure that a set of correctness conditions is satisfied in all cases.</p>
<p><em>Static Testing Properties</em></p>
<h5 id="1-type_7"><a name="user-content-1-type_7" href="#1-type_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The finite-state analysis tool leveraged <em>Symbolic Model-checking</em>.</p>
<h5 id="2-model-generation"><a name="user-content-2-model-generation" href="#2-model-generation" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Model Generation</h5>
<p>The model had to be specified <em>manually</em> in the Mur$\phi$ tool&rsquo;s design language.</p>
<p><em>Result Properties</em></p>
<h5 id="1-spurious-warnings_3"><a name="user-content-1-spurious-warnings_3" href="#1-spurious-warnings_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings?</h5>
<p>Although Mur$\phi$ was not vulnerable to false positives since it is a model-checker, it did uncover problems that were not necessarily direct threats to the security of SSL 3.0. </p>
<h5 id="2-missed-bugs_3"><a name="user-content-2-missed-bugs_3" href="#2-missed-bugs_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs?</h5>
<p>Since the Mur$\phi$ exhaustively tests the model, it is <em>not vulnerable</em> to missed bugs.</p>
<h5 id="3-form-of-vulnerabilities_3"><a name="user-content-3-form-of-vulnerabilities_3" href="#3-form-of-vulnerabilities_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>The form of the anomalies was <em>counterexamples</em> as is typical of model-checking.</p>
<h5 id="4-threat-assessment_3"><a name="user-content-4-threat-assessment_3" href="#4-threat-assessment_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>The threat assessment of the anomalies was done <em>automatically</em> though the generation of a potential attack. </p>
<p><em>D. A Messy State of the Union</em></p>
<p>The authors address the problem of designing a composite state machine that can multiplex between different protocol modes and then test several TLS implementations for state machine bugs.</p>
<p><em>Core Properties</em></p>
<h5 id="1-type_8"><a name="user-content-1-type_8" href="#1-type_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The authors analyze the state machines of multiple open source TLS implementations using <em>dynamic testing</em>.</p>
<h5 id="2-test-scope_4"><a name="user-content-2-test-scope_4" href="#2-test-scope_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The test scope for the dynamic testing is <em>system testing</em> since the implementations are viewed as black boxes.</p>
<h5 id="3-exceptional-element_4"><a name="user-content-3-exceptional-element_4" href="#3-exceptional-element_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p>The exceptional element in the case of the generation-based fuzzing is an <em>exceptional input</em> in the form of a sequence of valid TLS messages.</p>
<h5 id="4-test-oracle_4"><a name="user-content-4-test-oracle_4" href="#4-test-oracle_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>The test oracle for the dynamic testing is a <em>reference implementation</em>; the authors have a verified TLS state machine that is used to verify that a particular trace is valid or invalid (and thus that the implemetation should accept or reject it). The test oracle for the static testing is <em>manual inspection</em>.</p>
<h5 id="5-oracle-specification_4"><a name="user-content-5-oracle-specification_4" href="#5-oracle-specification_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Oracle Specification</h5>
<p>The specification for a particular trace is <em>automatically generated</em> in the sense that FlexTLS generates it and then the verified state machine accepts it.</p>
<h5 id="9-exit-criteria"><a name="user-content-9-exit-criteria" href="#9-exit-criteria" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>9. Exit Criteria</h5>
<p>The exit criteria for the dynamic testing is <em>exhaustion</em> of the test cases.</p>
<p><em>Dynamic Testing</em></p>
<h5 id="1-type_9"><a name="user-content-1-type_9" href="#1-type_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p><em>Generation-based fuzzing</em></p>
<h5 id="2-in-test-accessibility_3"><a name="user-content-2-in-test-accessibility_3" href="#2-in-test-accessibility_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. In-test Accessibility</h5>
<p>During the dynamic testing, the authors use FlexTLS to send arbitrary sequences of TLS messages to the implementations, and thus the dynamic testing is <em>black-box testing</em>.</p>
<h5 id="3-injection-vector_3"><a name="user-content-3-injection-vector_3" href="#3-injection-vector_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Injection Vector</h5>
<p>The injection vector is <em>simulated interaction</em>; FlexTLS simulates a clients connection to a server.</p>
<h5 id="4-instrumentation_3"><a name="user-content-4-instrumentation_3" href="#4-instrumentation_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Instrumentation</h5>
<p>The instrumentation for the dynamic testing is <em>in-band</em>, the authors expect to get an error message from the implementation.</p>
<p><em>Result Properties</em> </p>
<h5 id="1-spurious-warnings_4"><a name="user-content-1-spurious-warnings_4" href="#1-spurious-warnings_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings?</h5>
<p>The authors attempt to reduce false positives by using verified messaging libraries, but they cannot guarantee that no false positives will be generated with this methodology. Thus, the dynamic testing is <em>vulnerable</em> to false positives.</p>
<h5 id="2-missed-bugs_4"><a name="user-content-2-missed-bugs_4" href="#2-missed-bugs_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs?</h5>
<p>Since this is a form of dynamic testing without a formal notion of coverage; this method was <em>vulnerable</em> to missed bugs.</p>
<h5 id="3-form-of-vulnerabilities_4"><a name="user-content-3-form-of-vulnerabilities_4" href="#3-form-of-vulnerabilities_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>The form of vulnerabilities is <em>exceptional traces</em>, errors from the SUT as captured by the instrumentation.</p>
<h5 id="4-threat-assessment_4"><a name="user-content-4-threat-assessment_4" href="#4-threat-assessment_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>The threat assessment had to be done <em>manually</em>, though the manual code-based analysis. After the potential vulnerabilities exceptional traces were collected, the authors had to go through the faulting implementation(s) to discover the root cause of the problem.</p>
<p><em>E. Systematic Fuzzing and Testing of TLS Libraries</em></p>
<p>This paper presents TLS-Attacker, an open source framework for evaluating the security of TLS libraries through the creation of custom TLS message flows and the arbitrary modification of message contents. This framework is used to mount a two-stage fuzzing approach to evaluate TLS server behavior. </p>
<h5 id="1-type_10"><a name="user-content-1-type_10" href="#1-type_10" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The type of testing done is <em>dynamic testing</em>.</p>
<h5 id="2-test-scope_5"><a name="user-content-2-test-scope_5" href="#2-test-scope_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The test scope is <em>system testing</em> since the SUT is an entire particular TLS implementation, OpenSSL.</p>
<h5 id="3-exceptional-element_5"><a name="user-content-3-exceptional-element_5" href="#3-exceptional-element_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p>The exceptional element of both stages is an <em>exceptional input</em> of the form of a protocol flow. The authors used their framework to construct sequences of messages that caused the implementation to fail.</p>
<h5 id="4-test-oracle_5"><a name="user-content-4-test-oracle_5" href="#4-test-oracle_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>The test oracle in this case is <em>manual inspection</em> of the testing data; the TLS-Attacker framework stores exceptional protocols for later analysis by the authors.</p>
<h5 id="5-specification"><a name="user-content-5-specification" href="#5-specification" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Specification</h5>
<p>The specification is <em>manually determined</em> based on the authors&rsquo; knowledge of the TLS protocol.</p>
<h5 id="6-exit-criteria_4"><a name="user-content-6-exit-criteria_4" href="#6-exit-criteria_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Exit Criteria</h5>
<p>The exit criteria is <em>manual</em>. A user of the testing framework decides upon the the number of fuzzing attempts.</p>
<p><em>Dynamic Testing Properties</em></p>
<h5 id="1-type_11"><a name="user-content-1-type_11" href="#1-type_11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The two stage approach is to first perform restricted <em>random fuzzing</em> specifically targeted at triggering Bleichenbacher&rsquo;s attack, padding oracle attacks, invalid curve attacks, and POODLE. In the second stage, three phases of attacks are performed, but they all use <em>mutation-based fuzzing</em> to send protocol flows with randomly modified variables.</p>
<h5 id="2-accessibility"><a name="user-content-2-accessibility" href="#2-accessibility" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Accessibility</h5>
<p>The accessibility is <em>black-box</em>, the source code of implementations is not inspected during testing.</p>
<h5 id="3-injection-vector_4"><a name="user-content-3-injection-vector_4" href="#3-injection-vector_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Injection Vector</h5>
<p>The injection vector is a <em>simulated server</em>, the framework being used.</p>
<h5 id="4-instrumentation_4"><a name="user-content-4-instrumentation_4" href="#4-instrumentation_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Instrumentation</h5>
<p><em>Out-of-band</em> instrumentation is used. In order to detect buffer boundary violations or other memory corruptions, the authors utilize AddressSanitizer which monitors the program at runtime for memory errors. The authors also detect if an invalid protocol flow by using a TLS context analyzer. </p>
<p><em>Result Properties</em></p>
<h5 id="1-spurious-warnings_5"><a name="user-content-1-spurious-warnings_5" href="#1-spurious-warnings_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings</h5>
<p>This method is not <em>vulnerable</em> to false positives since some of the exceptional cases are not directly related to protocol bugs and may be the result of other errors.</p>
<h5 id="2-missed-bugs_5"><a name="user-content-2-missed-bugs_5" href="#2-missed-bugs_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs</h5>
<p>Since this approach is in no sense exhaustive, it is <em>vulnerable</em> to missed bugs.</p>
<h5 id="3-form-of-vulnerabilities_5"><a name="user-content-3-form-of-vulnerabilities_5" href="#3-form-of-vulnerabilities_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>The form of vulnerabilities is <em>exceptional traces</em> both in terms of the output of AddressSanitizer and the TLS context analyzer.</p>
<h5 id="4-threat-assessment_5"><a name="user-content-4-threat-assessment_5" href="#4-threat-assessment_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>The threat assessment had to be completed <em>manually</em>. Each potential vulnerability was analyzed by the authors.</p>
<p><em>F. Protocol state fuzzing of TLS implementations</em></p>
<p>The authors perform a systematic analysis of TLS implementations by using state machine learning to infer state machines from protocol implementations, and then check those state machines manually to look for spurious behavior. If spurious behavior is found, the authors then manually investigate the implementations to look for vulnerabilities.</p>
<h5 id="1-type_12"><a name="user-content-1-type_12" href="#1-type_12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The type of testing is <em>static testing</em>.</p>
<h5 id="2-test-scope_6"><a name="user-content-2-test-scope_6" href="#2-test-scope_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The scope of the testing is <em>component testing</em>. Testing is done over models generated using message flows in the TLS handshake and with the heartbeat protocol.</p>
<h5 id="3-exceptional-element_6"><a name="user-content-3-exceptional-element_6" href="#3-exceptional-element_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p>The exceptional element is not applicable as checking of the model was done though manual inspection.</p>
<h5 id="4-test-oracle_6"><a name="user-content-4-test-oracle_6" href="#4-test-oracle_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>The test oracle in this case is <em>manual inspection</em> of the generated models; the authors inspected the generated models to see whether they could fine superfluous or irregular states or transitions in the model.</p>
<h5 id="5-specification_1"><a name="user-content-5-specification_1" href="#5-specification_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Specification</h5>
<p>The specification is not applicable since the test oracle was manual inspection.</p>
<h5 id="6-exit-criteria_5"><a name="user-content-6-exit-criteria_5" href="#6-exit-criteria_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Exit Criteria</h5>
<p>The exit criteria for the testing is <em>manual</em>.</p>
<p><em>Static Testing Properties</em></p>
<h5 id="1-type_13"><a name="user-content-1-type_13" href="#1-type_13" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The checking of the model was done <em>manually</em>.</p>
<h5 id="2-model-generation_1"><a name="user-content-2-model-generation_1" href="#2-model-generation_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Model Generation</h5>
<p>The model was produced through <em>automatic generation</em>; the authors used state machine learning to infer the state machines from protocol implementations.</p>
<p><em>Result Properties</em></p>
<h5 id="1-spurious-warnings_6"><a name="user-content-1-spurious-warnings_6" href="#1-spurious-warnings_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings?</h5>
<p>This methodology is <em>vulnerable</em> to false positives since any misbehavior is considered to warrant inspection.</p>
<h5 id="2-missed-bugs_6"><a name="user-content-2-missed-bugs_6" href="#2-missed-bugs_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs?</h5>
<p>Since the models that are generated are not necessarily complete, and the inspection of the models is done manually, it cannot be guaranteed that this method is safe from missed bugs. Thus it is <em>vulnerable</em> to missed bugs.</p>
<h5 id="3-form-of-vulnerabilities_6"><a name="user-content-3-form-of-vulnerabilities_6" href="#3-form-of-vulnerabilities_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>The form of vulnerabilities is the <em>manually-inspected behavior</em> of the generated model.</p>
<h5 id="4-threat-assessment_6"><a name="user-content-4-threat-assessment_6" href="#4-threat-assessment_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>Threat assessment is done <em>manually</em>, if a spurious behavior is noticed in a generated model of a particular implementation, the authors then manually inspect the source code of that implementation.</p>
<p><em>G. Testing Embedded TLS Implementations</em></p>
<p>The authors present a methodology for the systematic testing of TLS implementations in the context of embedded devices such as Cyber Physical Systems. The authors leverage the principles behind the Frankencerts method and lift that system into the space of testing the entirety of the TLS implementation.</p>
<p><em>Core Properties</em></p>
<h5 id="1-type_14"><a name="user-content-1-type_14" href="#1-type_14" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The essence of the approach is <em>dynamic testing</em>.</p>
<h5 id="2-test-scope_7"><a name="user-content-2-test-scope_7" href="#2-test-scope_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Test Scope</h5>
<p>The authors strove to extend the results of <em>Frankencerts</em> to test more than just certificate validation; they attempted to conduct <em>system testing</em>.</p>
<h5 id="3-exceptional-element_7"><a name="user-content-3-exceptional-element_7" href="#3-exceptional-element_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Exceptional Element</h5>
<p>The exceptional element is in the form of <em>exceptional input</em> that is given to the SUT through its regular input channel.</p>
<h5 id="4-test-oracle_7"><a name="user-content-4-test-oracle_7" href="#4-test-oracle_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Test Oracle</h5>
<p>The approach uses a form of differential testing with structurally different TLS implementations of different origins. Thus, the test oracle is form of <em>reference implementation</em> akin to what is done with <em>Frankencerts</em>.</p>
<h5 id="5-oracle-specification_5"><a name="user-content-5-oracle-specification_5" href="#5-oracle-specification_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Oracle Specification</h5>
<p>Since the oracle is not one specific reference implementation, it is not formally specified or generated. The oracle is discrepancies amongst the responses and the content of the responses sent by the different TLS implementations under test.</p>
<h5 id="6-exit-criteria_6"><a name="user-content-6-exit-criteria_6" href="#6-exit-criteria_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Exit Criteria</h5>
<p>The exit criteria is <em>exhaustion</em> of the test cases.</p>
<p><em>Dynamic Testing Properties</em></p>
<h5 id="1-type_15"><a name="user-content-1-type_15" href="#1-type_15" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Type</h5>
<p>The form of fuzzing conducted is <em>mutation-based fuzzing</em> of sequences of messages fed to the SUT.</p>
<h5 id="2-in-test-accessibility_4"><a name="user-content-2-in-test-accessibility_4" href="#2-in-test-accessibility_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. In-test Accessibility</h5>
<p>During the testing the artifacts of development are not available to the tests, this this is a <em>black-box</em> approach.</p>
<h5 id="3-injection-vector_5"><a name="user-content-3-injection-vector_5" href="#3-injection-vector_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Injection Vector</h5>
<p>The injection vector is <em>simulated interaction</em>; sequences of messages are fed to the SUT.</p>
<h5 id="4-instrumentation_5"><a name="user-content-4-instrumentation_5" href="#4-instrumentation_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Instrumentation</h5>
<p>The instrumentation is <em>in-band</em>; the type of response received from the TLS implementations are collected and compared for differences.</p>
<p><em>Results Properties</em></p>
<h5 id="1-spurious-warnings_7"><a name="user-content-1-spurious-warnings_7" href="#1-spurious-warnings_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Spurious Warnings?</h5>
<p>This approach is <em>vulnerable</em> to spurious warnings; not every message flow sent to the SUT is guaranteed to be valid and thus flows that are not accounted for by the TLS specification might be sent, leading to undefined but not necessarily incorrect behavior.</p>
<h5 id="2-missed-bugs_7"><a name="user-content-2-missed-bugs_7" href="#2-missed-bugs_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Missed Bugs?</h5>
<p>The approach is <em>vulnerable</em> to missed bugs since the exit criteria is exhaustion of the test cases rather than some metric of coverage.</p>
<h5 id="3-form-of-vulnerabilities_7"><a name="user-content-3-form-of-vulnerabilities_7" href="#3-form-of-vulnerabilities_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Form of Vulnerabilities</h5>
<p>The form of the vulnerabilities is <em>exceptional traces</em> in the form of responses sent by the TLS implementations.</p>
<h5 id="4-threat-assessment_7"><a name="user-content-4-threat-assessment_7" href="#4-threat-assessment_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Threat Assessment</h5>
<p>The threat assessment must be done <em>manually</em>; this approach, like <em>Frankencerts</em> only uncovers discrepancies and does not provide any means for their classification.</p>
<h3 id="v-discussion-of-methodologies-and-results"><a name="user-content-v-discussion-of-methodologies-and-results" href="#v-discussion-of-methodologies-and-results" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>V. Discussion of Methodologies and Results</h3>
<p><center><img src="/Users/darioncassel/git/classwork/UVa/Y3S2/TLS/sok-tls-testing/img/chart_core.png" style="width:800px;"/><br><br />
<sup>Fig. 3: Core Properties Classification</sup></center></p>
<p><center><img src="/Users/darioncassel/git/classwork/UVa/Y3S2/TLS/sok-tls-testing/img/dynamic_vs_static.png" style="width:300px;"/><br><br />
<sup>Fig. 4: Dynamic vs Static Testing</sup></center></p>
<p><center><img src="/Users/darioncassel/git/classwork/UVa/Y3S2/TLS/sok-tls-testing/img/test_oracle_type.png" style="width:300px;"/><br><br />
<sup>Fig. 5: Test Oracle Type</sup></center></p>
<h3 id="vi-the-combined-approach"><a name="user-content-vi-the-combined-approach" href="#vi-the-combined-approach" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>VI. [!] The Combined Approach</h3>
<h3 id="vii-results-with-the-combined-approach"><a name="user-content-vii-results-with-the-combined-approach" href="#vii-results-with-the-combined-approach" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>VII. [!] Results with the Combined Approach</h3>
<h3 id="viii-related-works"><a name="user-content-viii-related-works" href="#viii-related-works" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>VIII. [!] Related Works</h3>
<h3 id="ix-future-research"><a name="user-content-ix-future-research" href="#ix-future-research" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>IX. [!] Future Research</h3>
<h3 id="x-references"><a name="user-content-x-references" href="#x-references" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>X. References</h3>
<p>[1] &ldquo;THE SSL PROTOCOL&rdquo;. Netscape Corporation. 2007.</p>
<p>[2] Rescorla, Eric. SSL and TLS: Designing and Building Secure Systems. 2001.</p>
<p>[3] Polk, Tim; McKay, Terry; Chokhani, Santosh (April 2014). &ldquo;Guidelines for the Selection, Configuration, and Use of Transport Layer Security (TLS) Implementations&rdquo; </p>
<p>[4] Dierks, T. &amp; E. Rescorla (April 2006). &ldquo;The Transport Layer Security (TLS) Protocol Version 1.1, RFC 4346&rdquo;.</p>
<p>[5] RFC 5246</p>
<p>[6] Thai Duong &amp; Juliano Rizzo (2011-05-13). &ldquo;Here Come The ⊕ Ninjas&rdquo;.</p>
<p>[7] Rizzo, Juliano; Duong, Thai. &ldquo;The CRIME attack&rdquo;</p>
<p>[8] Lucky Thirteen: Breaking the TLS and DTLS Record Protocols</p>
<p>[9] Bodo Möller, Thai Duong &amp; Krzysztof Kotowicz. &ldquo;This POODLE Bites: Exploiting The SSL 3.0 Fallback&rdquo;</p>
<p>[10] RFC 6176</p>
<p>[11] P. Bourque and R. Dupuis, editors. Guide to the Software Engineering<br />
Body of Knowledge Version 3.0 SWEBOK. IEEE, 2014.</p>
<p>[12] OWASP Testing Guide</p>
<p>[13] <a href="https://hpbn.co/transport-layer-security-tls/">https://hpbn.co/transport-layer-security-tls/</a></p>
<p>[14] RFC 5280</p>
<p>[15] P. Ammann and J. Offutt. Introduction to Software Testing. Cambridge University Press, Cambridge, UK, 2008.</p>
<p>[16] ISO/IEC. Information technology – open systems interconnection – conformance testing methodology and framework, 1994. International ISO/IEC multi–part standard No. 9646.</p>
<p>[17] Felderer, Michael et al. Security Testing: A Survey.</p>
<p>[18] Schulzrinne, Henning et al. Security testing of SIP implementations.</p>
<p>[19] Committee on National Security Systems. 4009, ”National Information Assurance Glossary”. Technical report, Committee on National Security Systems, 2010.</p>
<p>[20] IEEE. IEEE Standard for Software and System Test Documentation. IEEE Std 829-2008, 2008.</p>
<p>[21] K. Scarfone, M. Souppaya, A. Cody, and A. Orebaugh. Technical Guide to Information Security Testing and Assessment. Special Publication 800-115, National Institute of Standards and Technology (NIST), 2008.</p>
<p>[22] H. Shahriar and M. Zulkernine. Automatic testing of program security vulnerabilities. In Computer Software and Applications Conference, 2009. COMPSAC’09. 33rd Annual IEEE International, volume 2, pages 550–555. IEEE, 2009.</p>
<p>[23] D. Yang, Y. Zhang, and Q. Liu. Blendfuzz: A model-based framework for fuzz testing programs with grammatical inputs. In G. Min, Y. Wu, L. C. Liu, X. Jin, S. A. Jarvis, and A. Y. Al-Dubai, editors, 11th IEEE International Conference on Trust, Security and Privacy in Computing and Communications, TrustCom 2012, Liverpool, United Kingdom, June 25-27, 2012, pages 1070–1076. IEEE Computer Society, 2012.</p>
<p>[24] S. Bekrar, C. Bekrar, R. Groz, and L. Mounier. A taint based approach for smart fuzzing. In G. Antoniol, A. Bertolino, and Y. Labiche, editors, 2012 IEEE Fifth International Conference on Software Testing, Verification and Validation, Montreal, QC, Canada, April 17-21, 2012, pages 818–825. IEEE, 2012.</p>
<p>[25] D’Silva, Vijay et Al. A Survey of Automated Techniques for Formal Software Verification. Transactions on CAD.</p>
<p>[26] E. M. Clarke and E. A. Emerson. Design and synthesis of synchronization skeletons using branching-time temporal logic. In Logic of Programs, volume 131 of LNCS, pages 52–71. Springer, 1981.</p>
<p>[27] S. Demri, F. Laroussinie, and P. Schnoebelen. A parametric analysis of the state-explosion problem in model checking. Compututer and System Sciences, 72(4):547–575, 2006.</p>
<p>[28] R. E. Bryant. Graph-based algorithms for Boolean function manipulation. IEEE Transactions on Computers, 35(8):677–691, 1986.</p>
<p>[29] J. R. Buchi. Regular canonical systems. Archive for Mathematical Logic, 6(3-4):91, April 1964.</p>
<p>[30] Y. Kesten, O. Maler, M. Marcus, A. Pnueli, and E. Shahar. Symbolic model checking with rich ssertional languages. In Computer Aided<br />
Verification (CAV), volume 1254 of LNCS, pages 424–435. Springer, 1997.</p>
<p>[31] Blanchet, Bruno. Security Protocol Verification: Symbolic and Computational Models.</p>
<p>[32] Chad Brubaker, Suman Jana, Baishakhi Ray, Sarfraz Khurshid, and Vitaly Shmatikov. 2014. Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations. In Proceedings of the 2014 IEEE Symposium on Security and Privacy (SP &lsquo;14). IEEE Computer Society, Washington, DC, USA, 114-129.</p>
<p>[33] John C. Mitchell, Vitaly Shmatikov, and Ulrich Stern. 1998. Finite-state analysis of SSL 3.0. In Proceedings of the 7th conference on USENIX Security Symposium - Volume 7 (SSYM&lsquo;98), Vol. 7. USENIX Association, Berkeley, CA, USA, 16-16.</p>
<p>[34] David Kaloper-Meršinjak, Hannes Mehnert, Anil Madhavapeddy, and Peter Sewell. 2015. Not-quite-so-broken TLS: lessons in re-engineering a security protocol specification and implementation. In Proceedings of the 24th USENIX Conference on Security Symposium (SEC&lsquo;15), Jaeyeon Jung (Ed.). USENIX Association, Berkeley, CA, USA, 223-238.</p>
<p>[35] B. Beurdouche et al., &ldquo;A Messy State of the Union: Taming the Composite State Machines of TLS,&rdquo; 2015 IEEE Symposium on Security and Privacy, San Jose, CA, 2015, pp. 535-552.</p>
<p>[36] Juraj Somorovsky. 2016. Systematic Fuzzing and Testing of TLS Libraries. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security (CCS &lsquo;16). ACM, New York, NY, USA, 1492-1504</p>
<p>[37] Joeri de Ruiter and Erik Poll. Protocol State Fuzzing of TLS Implementations. 24th USENIX Security Symposium (USENIX Security 15). 2015. 978-1-931971-232. Washington, D.C. 193&ndash;206.</p>
<p>[38] Walz, Andreas, and Axel Sikora. &ldquo;Testing embedded TLS implementations using fuzzing techniques and differential testing.&rdquo; BW-CAR SINCOM (2015): 36.</p></article></body></html>